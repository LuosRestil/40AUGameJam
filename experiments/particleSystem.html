<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particle System</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>
    <script>
      const canvas = document.querySelector("canvas");
      canvas.width = document.body.clientWidth;
      canvas.height = document.body.clientHeight;
      const ctx = canvas.getContext("2d");

      document.addEventListener("click", (evt) => {
        generateParticleSystem({x: evt.offsetX, y: evt.offsetY});
      });

      document.addEventListener("keydown", () => {
        console.log(particleSystems);
      });

      const particleSystems = [];

      requestAnimationFrame(animate);

      function animate(timestamp) {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let ps of particleSystems) {
          ps.step(timestamp);
        }
        requestAnimationFrame(animate);
      }

      class Particle {
        position;
        velocity;
        lifetime;
        active;
        lastTime;
        createdTime;

        constructor(position, velocity, lifetime, createdTime) {
          this.position = position;
          this.velocity = velocity;
          this.lifetime = lifetime;
          this.active = true;
          this.createdTime = createdTime
          this.lastTime = createdTime;
        }

        run(timestamp) {
          this.update(timestamp);
          this.draw();
        }

        update(timestamp) {
          const deltaTimeSeconds = (timestamp - this.lastTime)/1000;
          this.lastTime = timestamp;

          this.position.x += this.velocity.x * deltaTimeSeconds;
          this.position.y += this.velocity.y * deltaTimeSeconds;

          if (timestamp - this.createdTime > this.lifetime) this.active = false;
        }

        draw() {
          ctx.fillStyle = "red";
          ctx.fillRect(this.position.x, this.position.y, 10, 10);
        }
      }

      class ParticleSystem {
        particles = [];
        minVel = -50;
        maxVel = 50;
        spawnRate = 200;
        lastSpawnTime = 0;
        origin;

        constructor(origin) {
          this.origin = origin;
        }

        step(timestamp) {
          const deltaTime = timestamp - this.lastSpawnTime;
          if (deltaTime > this.spawnRate) {
            this.spawnParticle(timestamp);
            this.lastSpawnTime = timestamp - (timestamp % this.spawnRate);
          }
          this.particles = this.particles.filter((particle) => particle.active);
          for (let particle of this.particles) {
            particle.run(timestamp);
          }
        }

        spawnParticle(timestamp) {
          this.particles.push(
            new Particle(
              {x: this.origin.x, y: this.origin.y},
              {
                x: this.minVel + Math.random() * (this.maxVel - this.minVel),
                y: this.minVel + Math.random() * (this.maxVel - this.minVel),
              },
              1000, // 1 second
              timestamp
            )
          );
        }
      }

      function generateParticleSystem(origin) {
        particleSystems.push(new ParticleSystem(origin));
      }
    </script>
  </body>
</html>
